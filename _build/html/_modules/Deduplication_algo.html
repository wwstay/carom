
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Deduplication_algo &#8212; Deduplication/Entity Resolution of supplier database  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Deduplication_algo</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: Deduplication_algo </span>
<span class="sd">   :synopsis: Core match making algorithm</span>

<span class="sd">.. moduleauthor:: Shubhang Goswami &lt;shubhang@wwstay.com&gt;</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">CoreBGgeneration</span>
<span class="kn">from</span> <span class="nn">pymongo</span> <span class="k">import</span> <span class="n">MongoClient</span>
<span class="kn">import</span> <span class="nn">prepare_4_EM</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pk</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">spatial</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">monary</span> <span class="k">import</span> <span class="n">Monary</span>
<span class="kn">from</span> <span class="nn">bson.code</span> <span class="k">import</span> <span class="n">Code</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">bson</span>
<span class="kn">import</span> <span class="nn">time</span>


<div class="viewcode-block" id="gen_probvec"><a class="viewcode-back" href="../Code.html#Deduplication_algo.gen_probvec">[docs]</a><span class="k">def</span> <span class="nf">gen_probvec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pCdict</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a vector of length number of words (each words corresponds to an index). For each hotel name/address the vector this function generates is:</span>
<span class="sd">    The core probability of word in each idx corresponding to words of the hotel name/address.</span>
<span class="sd">    (So if our total table was- &quot;Hotel A&quot; and &quot;B&quot; the vector would be of dim 3 and for &quot;Hotel A&quot; the vector would be [p(hotel),p(A),0] )</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        name (list): A list of tokenized words</span>
<span class="sd">        pCdict (dict): A dictionary containing the probability of word being core as a list for both tables</span>
<span class="sd">        i (int): index number indicating whether it comes from table 1 or 2</span>

<span class="sd">    Return:</span>
<span class="sd">        list: A sparse vector of num_words dimension with probabilities. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pCdict</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pCdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pCdict</span><span class="p">[</span><span class="n">word</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pCdict</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pCdict</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">vec</span></div>
    
<div class="viewcode-block" id="genreg_vec"><a class="viewcode-back" href="../Code.html#Deduplication_algo.genreg_vec">[docs]</a><span class="k">def</span> <span class="nf">genreg_vec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pCdict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a vector of length number of words (each words corresponds to an index). For each hotel name/address the vector this function generates is:</span>
<span class="sd">    For each word in a particular name/address, the vector has a 1 and for the rest 0.</span>
<span class="sd">    So if our total table was - &quot;hotel A&quot;,&quot;b&quot; then the vector would be 3 dimensional and for &quot;hotel A&quot; this function would spit out would be [1,1,0]</span>

<span class="sd">    Args:</span>
<span class="sd">        name (list): A list of tokenized words</span>
<span class="sd">        pCdict (dict): A dictionary containing the probability of a word being core (key=word, val=probability)</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: A one hot vector of num_of_words dimension </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pCdict</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">pCdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span>
        
    <span class="k">return</span> <span class="n">vec</span></div>

<div class="viewcode-block" id="add_vals_to_vectdic"><a class="viewcode-back" href="../Code.html#Deduplication_algo.add_vals_to_vectdic">[docs]</a><span class="k">def</span> <span class="nf">add_vals_to_vectdic</span><span class="p">(</span><span class="n">odict</span><span class="p">,</span><span class="n">addict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a dictionary that contains the probabilistic values of words of both the tables.</span>
<span class="sd">    So a key would be the word and the value would be a list (of max 2 elements when comparing 2 and if one word doesn&#39;t exist in both tables then only 1)</span>

<span class="sd">    Args:</span>
<span class="sd">        odict (dict): An ordered dictionary passed in with vals as list and keys as words</span>
<span class="sd">        addict (dict): The probabilities of each words you want to append to the ordered dictionary</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A ordered dictionary where the keys are words and values are lists of probabilities from different tables</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">addict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">odict</span><span class="p">:</span>
            <span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">odict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">odict</span></div>

<div class="viewcode-block" id="makecumulativedict"><a class="viewcode-back" href="../Code.html#Deduplication_algo.makecumulativedict">[docs]</a><span class="k">def</span> <span class="nf">makecumulativedict</span><span class="p">(</span><span class="n">p_corename1</span><span class="p">,</span><span class="n">p_corename2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function appends different word:prob dictionary for each table to a single dict with all words.</span>
<span class="sd">    (so the new dict has word:[prob1,prob2] for words common in both tables). This function is useful to produce vectors of probabilities (running gen_probvec) </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        p_corename1 (dict): Dictionary of word:probability from table 1</span>
<span class="sd">        p_corename2 (dict): Dictionary of word:probability from table 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        OrderedDict: A combined dictionary of word:list(probs) of both tables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vector_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p_corename1</span><span class="p">)])</span>
    <span class="n">vector_dict</span> <span class="o">=</span> <span class="n">add_vals_to_vectdic</span><span class="p">(</span><span class="n">vector_dict</span><span class="p">,</span><span class="n">p_corename1</span><span class="p">)</span>
    <span class="n">vector_dict</span> <span class="o">=</span> <span class="n">add_vals_to_vectdic</span><span class="p">(</span><span class="n">vector_dict</span><span class="p">,</span><span class="n">p_corename2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vector_dict</span></div>



<div class="viewcode-block" id="check_result"><a class="viewcode-back" href="../Code.html#Deduplication_algo.check_result">[docs]</a><span class="k">def</span> <span class="nf">check_result</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="n">idcolumn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function used to check accuracy, and extract values that were predicted wrong.</span>

<span class="sd">    Args:</span>
<span class="sd">        inp1 (DataFrame): Matched dataframe according to model</span>
<span class="sd">        inp2 (DataFrame): The original dataframe to which matching occured with human matched values</span>
<span class="sd">        idcolumn (str): The column name where the algorithm outputted the matches</span>
<span class="sd">    Returns:</span>
<span class="sd">        triplet: Three DataFrames that include the merged dataframe after prediction, the ones that were wrong and the third dataframe with the wrong outputs merged with table 2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="n">idcolumn</span><span class="p">],</span><span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mapped_to_ext_id&quot;</span><span class="p">])</span>
    <span class="n">falses</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">idcolumn</span><span class="p">]</span><span class="o">!=</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;mapped_to_ext_id_x&quot;</span><span class="p">]]</span>
    <span class="nb">print</span> <span class="s2">&quot;Acc: &quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">idcolumn</span><span class="p">]</span><span class="o">==</span><span class="n">result</span><span class="p">[</span><span class="s2">&quot;mapped_to_ext_id_x&quot;</span><span class="p">]])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;num falses: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">falses</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s2">&quot;num total: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="n">wrongones</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">falses</span><span class="p">[[</span><span class="s2">&quot;name_x&quot;</span><span class="p">,</span><span class="s2">&quot;address_x&quot;</span><span class="p">,</span><span class="s2">&quot;mapped_to_ext_id_x&quot;</span><span class="p">,</span><span class="n">idcolumn</span><span class="p">]],</span><span class="n">inp2</span><span class="p">[[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span><span class="s2">&quot;address&quot;</span><span class="p">,</span><span class="s2">&quot;mapped_to_ext_id&quot;</span><span class="p">]],</span><span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mapped_to_ext_id_x&quot;</span><span class="p">],</span><span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mapped_to_ext_id&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span><span class="n">falses</span><span class="p">,</span><span class="n">wrongones</span></div>



<div class="viewcode-block" id="getColsfromdb"><a class="viewcode-back" href="../Code.html#Deduplication_algo.getColsfromdb">[docs]</a><span class="k">def</span> <span class="nf">getColsfromdb</span><span class="p">(</span><span class="n">supplier_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Monary requires column names and their respective types as input for its query. Thif function obtains the column names and a list of their respective types are generated.</span>

<span class="sd">    .. note:: There is a better way to get types along with names by mongo programming. If interested contact me, and I will send you an email from the guy who wrote monary.</span>

<span class="sd">    Args:</span>
<span class="sd">        supplier_name (str): Name of the collection in supplier_static_database</span>
<span class="sd">    Returns:</span>
<span class="sd">        pair: A pair of lists. (the column names,their respective types) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">MongoClient</span><span class="p">()</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">client</span><span class="p">[</span><span class="s1">&#39;supplier_static_database&#39;</span><span class="p">]</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="n">Code</span><span class="p">(</span><span class="s2">&quot;function(){   for (var key in this) {emit(key,null);} }&quot;</span><span class="p">)</span> 
    <span class="n">reduce</span> <span class="o">=</span> <span class="n">Code</span><span class="p">(</span><span class="s2">&quot;function(key, stuff) {return null;}&quot;</span><span class="p">)</span>
    <span class="n">pT</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">supplier_name</span><span class="p">)</span>

    <span class="n">mR</span> <span class="o">=</span> <span class="n">pT</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span><span class="n">reduce</span><span class="p">,</span><span class="n">supplier_name</span> <span class="o">+</span> <span class="s2">&quot;_keys&quot;</span><span class="p">)</span>
    <span class="n">types_</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pT</span><span class="o">.</span><span class="n">find</span><span class="p">()</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
    <span class="n">cols4db</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">mR</span><span class="o">.</span><span class="n">find</span><span class="p">():</span>
        <span class="n">cols4db</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span>
    <span class="n">cols4db</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cols4db</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">types_</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;unicode&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">types_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;string:50&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;ObjectId&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">types_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;id&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;list&quot;</span> <span class="ow">in</span> <span class="n">t</span> <span class="ow">or</span> <span class="s2">&quot;NoneType&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">types_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;string:50&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;int&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">types_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">types_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;float64&quot;</span>
            
    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">types_</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cols4db</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">tmpdiff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types_</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">cols4db</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tmpdiff</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">tmpdiff</span><span class="p">)):</span>
                <span class="n">types_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;string:10&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">cols4db</span><span class="p">[</span><span class="o">-</span><span class="n">tmpdiff</span><span class="p">:]</span>
            
    <span class="k">return</span> <span class="n">cols4db</span><span class="p">,</span><span class="n">types_</span></div>

    

<div class="viewcode-block" id="getMonaryDF"><a class="viewcode-back" href="../Code.html#Deduplication_algo.getMonaryDF">[docs]</a><span class="k">def</span> <span class="nf">getMonaryDF</span><span class="p">(</span><span class="n">supplier_name</span><span class="p">,</span><span class="n">colnames</span><span class="p">,</span><span class="n">types</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates the dataframe extracted from mongodb</span>

<span class="sd">    Args:</span>
<span class="sd">        supplier_name (str): The name of the collection in supplier_static_database</span>
<span class="sd">        colnames (list): List of column names of the collection </span>
<span class="sd">        types (list): List of column types of the collection </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame: The extracted dataframe from mongodb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">Monary</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;supplier_static_database&quot;</span><span class="p">,</span><span class="n">supplier_name</span><span class="p">,{},</span><span class="n">colnames</span><span class="p">,</span><span class="n">types</span><span class="p">)</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">colnames</span><span class="p">)</span>
    <span class="n">dat</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">dat</span><span class="p">[[</span><span class="s2">&quot;Latitude&quot;</span><span class="p">,</span><span class="s2">&quot;Longitude&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[[</span><span class="s2">&quot;Latitude&quot;</span><span class="p">,</span><span class="s2">&quot;Longitude&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="s1">&#39;mapped_to_ext_id&#39;</span><span class="p">])]</span>
    <span class="c1">#dat.columns = map(unicode,dat.columns)</span>
    <span class="k">return</span> <span class="n">dat</span></div>

<div class="viewcode-block" id="create_distribution"><a class="viewcode-back" href="../Code.html#Deduplication_algo.create_distribution">[docs]</a><span class="k">def</span> <span class="nf">create_distribution</span><span class="p">(</span><span class="n">prop1</span><span class="p">,</span><span class="n">prop2</span><span class="p">,</span><span class="n">supplier_name1</span><span class="p">,</span><span class="n">supplier_name2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is the heart. Running this runs your whold deduplication between supplier_name1 and supplier_name2.</span>

<span class="sd">    .. note:: This function contains parallel programming. The problem of PP hasn&#39;t been fixed and I urge you to take a look and solve that.</span>

<span class="sd">    Args:</span>
<span class="sd">        prop1 (DataFrame): DataFrame object for property 1 we are using to compare</span>
<span class="sd">        prop2 (DataFrame): DataFrame object for property 2 we are using to compare</span>
<span class="sd">        supplier_name1 (str): Name of table where we got prop1 properties from </span>
<span class="sd">        supplier_name2 (str): Name of table where we got prop2 properties from</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame: The overall matched resolved dataframe.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ccolsaddr1</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">get_relevcols</span><span class="p">(</span><span class="n">prop1</span><span class="p">,</span><span class="s2">&quot;address&quot;</span><span class="p">)</span>
    <span class="n">ccolsname1</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">get_relevcols</span><span class="p">(</span><span class="n">prop1</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
    
    <span class="n">ccolsaddr2</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">get_relevcols</span><span class="p">(</span><span class="n">prop2</span><span class="p">,</span><span class="s2">&quot;address&quot;</span><span class="p">)</span>
    <span class="n">ccolsname2</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">get_relevcols</span><span class="p">(</span><span class="n">prop2</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">appendercols</span><span class="p">(</span><span class="n">ccols</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ccols</span><span class="p">:</span>
            <span class="n">val</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">prop</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
        <span class="n">prop</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ccols</span><span class="p">:</span>
            <span class="n">prop</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">]</span><span class="o">+=</span><span class="n">prop</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">prop</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccolsaddr1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">appendercols</span><span class="p">(</span><span class="n">ccolsaddr1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccolsname1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">appendercols</span><span class="p">(</span><span class="n">ccolsname1</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccolsaddr2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">appendercols</span><span class="p">(</span><span class="n">ccolsaddr2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccolsname2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">appendercols</span><span class="p">(</span><span class="n">ccolsname2</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;emfeatures_&quot;</span><span class="o">+</span><span class="n">supplier_name1</span><span class="o">+</span><span class="s2">&quot;.pk&quot;</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">prepareem</span><span class="p">(</span><span class="n">prop1</span><span class="p">,</span><span class="n">supplier_name1</span><span class="p">)</span>
        
    <span class="k">try</span><span class="p">:</span>
        <span class="n">params2</span> <span class="o">=</span> <span class="n">pk</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;emfeatures_&quot;</span><span class="o">+</span><span class="n">supplier_name2</span><span class="o">+</span><span class="s2">&quot;.pk&quot;</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">params2</span> <span class="o">=</span> <span class="n">prepare_4_EM</span><span class="o">.</span><span class="n">prepareem</span><span class="p">(</span><span class="n">prop2</span><span class="p">,</span><span class="n">supplier_name2</span><span class="p">)</span>
    
    <span class="n">citynames1</span> <span class="o">=</span> <span class="n">params1</span><span class="o">.</span><span class="n">city</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
    
    <span class="n">citynames2</span> <span class="o">=</span> <span class="n">params2</span><span class="o">.</span><span class="n">city</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">cities</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">citynames1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">citynames2</span><span class="p">))</span>
    
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.8</span>
    
    <span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cities</span><span class="p">):</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">params1</span><span class="p">[</span><span class="n">params1</span><span class="o">.</span><span class="n">city</span><span class="o">==</span><span class="n">c</span><span class="p">]</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">params2</span><span class="p">[</span><span class="n">params2</span><span class="o">.</span><span class="n">city</span><span class="o">==</span><span class="n">c</span><span class="p">]</span>
        <span class="n">processes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">city_wide_dedup</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">processes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="n">e</span>
            <span class="nb">print</span> <span class="n">c</span>
            <span class="n">processes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s2">&quot;Slacking worker terminated&quot;</span>
    

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        
    <span class="n">result</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="city_wide_dedup"><a class="viewcode-back" href="../Code.html#Deduplication_algo.city_wide_dedup">[docs]</a><span class="k">def</span> <span class="nf">city_wide_dedup</span><span class="p">(</span><span class="n">cityparam1</span><span class="p">,</span><span class="n">cityparam2</span><span class="p">,</span><span class="n">city_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The algorithm that is being run in parallel and matching properties city by city</span>

<span class="sd">    Args:</span>
<span class="sd">        cityparam1 (DataFrame): The subset of properties from table 1 of a particular city</span>
<span class="sd">        cityparam2 (DataFrame): The subset of properties from table 2 of a particular city</span>
<span class="sd">        city_name (str): Name of the city we are subsetting</span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame: A dataframe same as cityparam1 with predicted matches appended in a new column called &quot;final_mapped&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pname1</span><span class="p">,</span><span class="n">paddr1</span> <span class="o">=</span> <span class="n">city_wide_distr</span><span class="p">(</span><span class="n">cityparam1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="n">city_name</span><span class="p">)</span>
    <span class="n">pname2</span><span class="p">,</span><span class="n">paddr2</span> <span class="o">=</span> <span class="n">city_wide_distr</span><span class="p">(</span><span class="n">cityparam2</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="n">city_name</span><span class="p">)</span>
    
    <span class="n">vector_dict_Pcorename</span> <span class="o">=</span> <span class="n">makecumulativedict</span><span class="p">(</span><span class="n">pname1</span><span class="p">,</span><span class="n">pname2</span><span class="p">)</span>
    <span class="n">vector_dict_Pcoreaddr</span> <span class="o">=</span> <span class="n">makecumulativedict</span><span class="p">(</span><span class="n">paddr1</span><span class="p">,</span><span class="n">paddr2</span><span class="p">)</span>
    
    <span class="n">cityparam1</span><span class="p">[</span><span class="s2">&quot;final_mapped&quot;</span><span class="p">]</span><span class="o">=</span> <span class="n">cityparam1</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">matchrecord</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pname1</span><span class="p">,</span><span class="n">paddr1</span><span class="p">,</span>
                                              <span class="n">cityparam2</span><span class="p">,</span>
                                              <span class="n">pname2</span><span class="p">,</span><span class="n">paddr2</span><span class="p">,</span><span class="n">vector_dict_Pcorename</span><span class="p">,</span>
                                              <span class="n">vector_dict_Pcoreaddr</span><span class="p">),</span>
                                              <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cityparam1</span></div>



<div class="viewcode-block" id="DB_dedup"><a class="viewcode-back" href="../Code.html#Deduplication_algo.DB_dedup">[docs]</a><span class="k">def</span> <span class="nf">DB_dedup</span><span class="p">(</span><span class="n">supplier_name1</span><span class="p">,</span><span class="n">supplier_name2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The wrapper that just takes two supplier names and calls other functions to complete the match making</span>

<span class="sd">    Args:</span>
<span class="sd">        supplier_name1 (str): The name of the collection 1 in supplier_static_database</span>
<span class="sd">        supplier_name2 (str): The name of the collection 2 in supplier_static_database</span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame: The final dataframe with mapped properties </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colnames1</span><span class="p">,</span><span class="n">types1</span> <span class="o">=</span> <span class="n">getColsfromdb</span><span class="p">(</span><span class="n">supplier_name1</span><span class="p">)</span>
    <span class="n">colnames2</span><span class="p">,</span><span class="n">types2</span> <span class="o">=</span> <span class="n">getColsfromdb</span><span class="p">(</span><span class="n">supplier_name2</span><span class="p">)</span>
    
    <span class="n">prop1</span> <span class="o">=</span> <span class="n">getMonaryDF</span><span class="p">(</span><span class="n">supplier_name1</span><span class="p">,</span><span class="n">colnames1</span><span class="p">,</span><span class="n">types1</span><span class="p">)</span>
    <span class="n">prop2</span> <span class="o">=</span> <span class="n">getMonaryDF</span><span class="p">(</span><span class="n">supplier_name2</span><span class="p">,</span><span class="n">colnames2</span><span class="p">,</span><span class="n">types2</span><span class="p">)</span>
    
    <span class="n">netres</span> <span class="o">=</span> <span class="n">create_distribution</span><span class="p">(</span><span class="n">prop1</span><span class="p">,</span><span class="n">prop2</span><span class="p">,</span><span class="n">supplier_name1</span><span class="p">,</span><span class="n">supplier_name2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">netres</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
        




<div class="viewcode-block" id="city_wide_distr"><a class="viewcode-back" href="../Code.html#Deduplication_algo.city_wide_distr">[docs]</a><span class="k">def</span> <span class="nf">city_wide_distr</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates required probability distribution of names and addresses</span>

<span class="sd">    Args:</span>
<span class="sd">        params (DataFrame): The dataframe of cleaned and tokenized properties with names and addresses</span>
<span class="sd">        alpha (float): The weight of core words. If alpha is 1, all words are regarded as core words and if alpha is 0 all words are regarded as background</span>
<span class="sd">        filename (str): Name to save distributions to pickle file. Would work if save is True.</span>
<span class="sd">        save (bool): If save is True, it will save the distribution to pickle file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pair: (core probability of words in hotel names, core probability of words in hotel addresses) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Working with only london properties as of now</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">name</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">address</span>
   
    <span class="c1">#Bring out the Core and Background distributions from the EM algorithm of name</span>
    <span class="n">pC_distr_name</span><span class="p">,</span><span class="n">pB_distr_name</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">core_algo1</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="n">pC_distr_addr</span><span class="p">,</span> <span class="n">pB_distr_addr</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">core_algo1</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

    
    <span class="c1">#Generate probability of being a core</span>
    <span class="n">pcore_name</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">coreprob</span><span class="p">(</span><span class="n">pC_distr_name</span><span class="p">,</span><span class="n">pB_distr_name</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">pcore_addr</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">coreprob</span><span class="p">(</span><span class="n">pC_distr_addr</span><span class="p">,</span><span class="n">pB_distr_addr</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">pk</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="n">pcore_name</span><span class="p">,</span><span class="n">pcore_addr</span><span class="p">),</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s2">&quot;distributions.pk&quot;</span><span class="p">,</span><span class="s2">&quot;wb&quot;</span><span class="p">))</span>
        <span class="nb">print</span> <span class="s2">&quot;File: &quot;</span><span class="p">,</span> <span class="n">filename</span><span class="o">+</span><span class="s2">&quot;distributions.pk created&quot;</span>
    <span class="k">return</span> <span class="n">pcore_name</span><span class="p">,</span><span class="n">pcore_addr</span></div>


<div class="viewcode-block" id="get_cossim"><a class="viewcode-back" href="../Code.html#Deduplication_algo.get_cossim">[docs]</a><span class="k">def</span> <span class="nf">get_cossim</span><span class="p">(</span><span class="n">row2</span><span class="p">,</span><span class="n">row1</span><span class="p">,</span><span class="n">vect_name</span><span class="p">,</span><span class="n">vect_addr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the cossine similarity between two vectors. It concatenates vectors of name and address into a larger dimensional vector and computes the cossine similarity</span>
<span class="sd">    This function is used as an apply function.</span>

<span class="sd">    Args:</span>
<span class="sd">        row2 (Series): A row of a dataframe2</span>
<span class="sd">        row1 (Series): A row of a dataframe1</span>
<span class="sd">        vect_name (dict): The cumulative vector dictionary made from makecumulativedict for names</span>
<span class="sd">        vect_addr (dict): The cumulative vector dictionary made from makecumulativedict for addresses</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        float: The similarity measure</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">genvec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">genreg_vec</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span><span class="n">vect_name</span><span class="p">),</span> <span class="n">genreg_vec</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">],</span><span class="n">vect_addr</span><span class="p">)])</span>
    <span class="n">genvec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">genreg_vec</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span><span class="n">vect_name</span><span class="p">),</span> <span class="n">genreg_vec</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">],</span><span class="n">vect_addr</span><span class="p">)])</span>
    <span class="n">sim_measure_gen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cosine</span><span class="p">(</span><span class="n">genvec1</span><span class="p">,</span><span class="n">genvec2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sim_measure_gen</span><span class="p">):</span>
                <span class="n">sim_measure_gen</span> <span class="o">=</span> <span class="mf">0.0</span>
            
    <span class="k">return</span> <span class="n">sim_measure_gen</span></div>
    
    



<div class="viewcode-block" id="vect_matchmaker"><a class="viewcode-back" href="../Code.html#Deduplication_algo.vect_matchmaker">[docs]</a><span class="k">def</span> <span class="nf">vect_matchmaker</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">vect_name</span><span class="p">,</span><span class="n">vect_addr</span><span class="p">,</span> <span class="n">data2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper to apply cossine similarity measure for each row in dataframe2. This function is used as an apply function.</span>

<span class="sd">    Args:</span>
<span class="sd">        row (Series): A row of a dataframe1</span>
<span class="sd">        vect_name (dict): An ordered dictionary of words of names from both DataFrames</span>
<span class="sd">        vect_addr (dict):  An ordered dictionary of words of addresses from both DataFrames</span>
<span class="sd">        data2 (DataFrame): The whole second dataframe to match with</span>
<span class="sd">    Returns:</span>
<span class="sd">        Series: A series of cossine similarities of row with every single entry in data2 </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">measure</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_cossim</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">vect_name</span><span class="p">,</span><span class="n">vect_addr</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">measure</span></div>
    


<div class="viewcode-block" id="haverdist"><a class="viewcode-back" href="../Code.html#Deduplication_algo.haverdist">[docs]</a><span class="k">def</span> <span class="nf">haverdist</span><span class="p">(</span><span class="n">row2</span><span class="p">,</span><span class="n">row1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that computes haversine distance between two pairs of latitudes and longitudes</span>
<span class="sd">    Used as an apply function</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        row2 (Series): A row of a dataframe2</span>
<span class="sd">        row1 (Series): A row of a dataframe1</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: 1-haversine_distance between entry in row1 and entry in row2. So 1 indicates on top of each other, while 0 indicates very far.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">longitude</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>
        
    <span class="n">lat1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">lon1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>
    <span class="n">lat2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>
    <span class="n">lon2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">row2</span><span class="o">.</span><span class="n">longitude</span><span class="p">)</span>

    <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="p">)</span></div>




<div class="viewcode-block" id="distprobs"><a class="viewcode-back" href="../Code.html#Deduplication_algo.distprobs">[docs]</a><span class="k">def</span> <span class="nf">distprobs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">data2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper to apply haversine distance metric to entries between a row in dataframe1 to every entry in dataframe2</span>

<span class="sd">    Args:</span>
<span class="sd">        row (Series): A row of a dataframe1</span>
<span class="sd">        data2 (DataFrame): The dataframe to match dataframe1 with.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Series: A series of haveresine closeness for entry in row 1 with every entry in data2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">haverdist</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">row</span><span class="p">,),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dists</span></div>



<div class="viewcode-block" id="matching"><a class="viewcode-back" href="../Code.html#Deduplication_algo.matching">[docs]</a><span class="k">def</span> <span class="nf">matching</span><span class="p">(</span><span class="n">row2</span><span class="p">,</span><span class="n">row1</span><span class="p">,</span><span class="n">pCname_self</span><span class="p">,</span><span class="n">pCaddr_self</span><span class="p">,</span> <span class="n">pCsent_name</span><span class="p">,</span> <span class="n">pCsent_addr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function runs the dedup algorithm from CoreBGgeneration for hotel names and addresses.</span>

<span class="sd">    Args:</span>
<span class="sd">        row2 (Series): A row of a dataframe2</span>
<span class="sd">        row1 (Series): A row of a dataframe1</span>
<span class="sd">        pCname_self: The word core probabilities for hotel names in dataframe2</span>
<span class="sd">        pCaddr_self: The word core probabilities for hotel addresses in dataframe2</span>
<span class="sd">        pCsent_name: The word core probabilities for hotel names in dataframe1</span>
<span class="sd">        pCsent_addr: The word core probabilities for hotel addresses in dataframe1</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The probability of being a match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_prob</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">dedup</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span><span class="n">row2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span><span class="n">pCsent_name</span><span class="p">,</span><span class="n">pCname_self</span><span class="p">)</span>
    <span class="n">addr_prob</span> <span class="o">=</span> <span class="n">CoreBGgeneration</span><span class="o">.</span><span class="n">dedup</span><span class="p">(</span><span class="n">row1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">],</span><span class="n">row2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;address&quot;</span><span class="p">],</span><span class="n">pCsent_addr</span><span class="p">,</span><span class="n">pCaddr_self</span><span class="p">)</span>
    <span class="c1">#print &quot;name:address probability, &quot;, name_prob, address_prob</span>
    <span class="k">return</span> <span class="n">name_prob</span><span class="o">*</span><span class="p">(</span><span class="n">addr_prob</span><span class="o">+</span><span class="mf">0.2</span><span class="o">*</span><span class="n">name_prob</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="matchrecord"><a class="viewcode-back" href="../Code.html#Deduplication_algo.matchrecord">[docs]</a><span class="k">def</span> <span class="nf">matchrecord</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">pCname_self</span><span class="p">,</span><span class="n">pCaddr_self</span><span class="p">,</span><span class="n">data2</span><span class="p">,</span><span class="n">pCname2</span><span class="p">,</span><span class="n">pCaddr2</span><span class="p">,</span><span class="n">vect_name</span><span class="p">,</span><span class="n">vect_addr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function combines all different models and methods into one and provides the best match as result.</span>
<span class="sd">    .. note:: This needs to improve in terms of how much weight/how much should we listen to which model. This is a common ensemble method problem, and should be solved with the training set provided.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        row (Series): A row of a dataframe1</span>
<span class="sd">        pCname_self (dict): The word core probabilities for hotel names in dataframe1</span>
<span class="sd">        pCaddr_self (dict): The word core probabilities for hotel addresses in dataframe1</span>
<span class="sd">        data2 (DataFrame): The dataframe to match with</span>
<span class="sd">        pCname2 (dict): The word core probabilities for hotel names in dataframe2</span>
<span class="sd">        pCaddr2 (dict): The word core probabilities for hotel addresses in dataframe2</span>
<span class="sd">        vect_name (dict): An ordered dictionary of words of names from both DataFrames</span>
<span class="sd">        vect_addr (dict): An ordered dictionary of words of addresses from both DataFrames</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The index with the maximum probability of being a match, or &quot;none&quot; if none found</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">probs</span><span class="o">=</span><span class="n">data2</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">matching</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">pCname2</span><span class="p">,</span><span class="n">pCaddr2</span><span class="p">,</span><span class="n">pCname_self</span><span class="p">,</span><span class="n">pCaddr_self</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="n">vect_prob</span> <span class="o">=</span> <span class="n">vect_matchmaker</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">vect_name</span><span class="p">,</span><span class="n">vect_addr</span><span class="p">,</span><span class="n">data2</span><span class="p">)</span>

    <span class="n">latlongprob</span> <span class="o">=</span> <span class="n">distprobs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">data2</span><span class="p">)</span>
    
    <span class="n">fnalprobs</span> <span class="o">=</span> <span class="mf">0.14</span><span class="o">*</span><span class="n">probs</span> <span class="o">+</span> <span class="mf">0.86</span><span class="o">*</span><span class="n">vect_prob</span> <span class="o">+</span> <span class="n">latlongprob</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">probs</span> <span class="o">+</span> <span class="n">vect_prob</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">&lt;=</span><span class="mf">1e-06</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;none&quot;</span>
    
    <span class="k">return</span> <span class="n">data2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">probs</span><span class="o">.</span><span class="n">idxmax</span><span class="p">(),</span><span class="s2">&quot;mapped_to_ext_id&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../Code.html#Deduplication_algo.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    main function to start with. This will make a comparison between two properties belonging to mongo. Right now it is tuned to hotelbeds_properties and taap_properties. Update those for different suppliers.</span>
<span class="sd">    Also calculates the time taken for the whole process to run from start to finish.</span>
<span class="sd">    Args:</span>
<span class="sd">        None</span>
<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">chained_assignment</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s2">&quot;Starting at: &quot;</span><span class="p">,</span> <span class="n">start_time</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fnal_df</span> <span class="o">=</span> <span class="n">DB_dedup</span><span class="p">(</span><span class="s2">&quot;hotelbeds_properties&quot;</span><span class="p">,</span><span class="s2">&quot;taap_properties&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- </span><span class="si">%s</span><span class="s2"> seconds ---&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>

    <span class="nb">print</span> <span class="s2">&quot;End of process&quot;</span>
    <span class="n">pk</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">fnal_df</span><span class="p">,</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hotelbeds_taap_dedup_results.pk&quot;</span><span class="p">,</span><span class="s2">&quot;wb&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- </span><span class="si">%s</span><span class="s2"> seconds ---&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>

<span class="c1">#get_ipython().run_cell_magic(u&#39;time&#39;, u&#39;&#39;, u&#39;%%capture capt\nreload(CoreBGgeneration)\nreload(prepare_4_EM)\nfnal_df = DB_dedup(&quot;hotelbeds_properties&quot;,&quot;taap_properties&quot;)&#39;)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Shubhang Goswami.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>